"""
FastAPI routes - All API endpoints for the Architect platform.
Handles projects, sessions, chat, and streaming responses.
"""
import json
import logging
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, HTTPException, Query
from fastapi.responses import StreamingResponse

from app.agents.graph import run_graph, run_graph_stream
from app.models.schemas import (
    ChatRequest,
    ProjectCreateRequest,
    SessionCreateRequest,
)
from app.services.db_service import db_service

logger = logging.getLogger(__name__)
router = APIRouter()


# ------------------------------------------------------------------
# PROJECTS
# ------------------------------------------------------------------

@router.post("/projects", summary="Create a new project")
async def create_project(request: ProjectCreateRequest):
    """Create a new project and return the project record."""
    try:
        project = await db_service.create_project(
            name=request.name,
            description=request.description
        )
        return {"success": True, "project": project}
    except Exception as e:
        logger.error(f"Create project error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}", summary="Get project details")
async def get_project(project_id: str):
    """Fetch a project by ID."""
    project = await db_service.get_project(project_id)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    return {"success": True, "project": project}


# ------------------------------------------------------------------
# SESSIONS
# ------------------------------------------------------------------

@router.post("/sessions", summary="Create a new session")
async def create_session(request: SessionCreateRequest):
    """Create a new conversation session for a project."""
    try:
        session = await db_service.create_session(str(request.project_id))
        return {"success": True, "session": session}
    except Exception as e:
        logger.error(f"Create session error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/sessions/{session_id}", summary="Get session details")
async def get_session(session_id: str):
    """Fetch a session and its current state."""
    session = await db_service.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    return {"success": True, "session": session}


@router.get("/sessions/{session_id}/messages", summary="Get chat history")
async def get_messages(session_id: str):
    """Fetch all messages for a session."""
    messages = await db_service.get_messages(session_id)
    return {"success": True, "messages": messages}


@router.get("/sessions/{session_id}/spec", summary="Get technical spec")
async def get_technical_spec(session_id: str):
    """Fetch the Planner-generated technical specification."""
    spec = await db_service.get_technical_spec(session_id)
    if not spec:
        raise HTTPException(status_code=404, detail="Technical spec not found")
    return {"success": True, "spec": spec}


@router.get("/sessions/{session_id}/docs", summary="Get documentation links")
async def get_documentation_links(session_id: str):
    """Fetch all documentation links found by the Librarian."""
    docs = await db_service.get_documentation_links(session_id)
    return {"success": True, "docs": docs}


@router.get("/sessions/{session_id}/scaffolds", summary="Get code scaffolds")
async def get_code_scaffolds(session_id: str):
    """Fetch all code scaffolds generated by the Mentor."""
    scaffolds = await db_service.get_code_scaffolds(session_id)
    return {"success": True, "scaffolds": scaffolds}


# ------------------------------------------------------------------
# CHAT (Main orchestration endpoint)
# ------------------------------------------------------------------

@router.post("/chat", summary="Send a message to the Architect")
async def chat(request: ChatRequest):
    """
    Main chat endpoint.
    Routes the message through the LangGraph orchestration pipeline.
    Returns the full response after all agents complete.
    """
    session_id = str(request.session_id)

    # Validate session exists
    session = await db_service.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")

    try:
        # Save user message
        await db_service.save_message(
            session_id=session_id,
            role="user",
            content=request.message,
            phase=session.get("current_phase"),
        )

        # Restore existing state from session metadata
        existing_state = session.get("metadata", {}).get("graph_state")
        
        # Load message history from database
        message_history = await db_service.get_messages(session_id)
        
        # Convert database messages to graph format
        graph_messages = [
            {
                "role": msg["role"],
                "content": msg["content"]
            }
            for msg in message_history
        ]
        
        # Add message history to state if we have one
        if existing_state:
            existing_state["messages"] = graph_messages
        else:
            # Create new state with message history
            existing_state = {
                "messages": graph_messages
            }

        # Run the LangGraph pipeline
        final_state = await run_graph(
            session_id=session_id,
            user_input=request.message,
            existing_state=existing_state,
        )

        # Extract the latest assistant message
        assistant_messages = [
            m for m in final_state.get("messages", [])
            if m.get("role") == "assistant"
        ]
        latest_response = assistant_messages[-1]["content"] if assistant_messages else "No response generated."

        # Persist updates to database
        await _persist_state_updates(session_id, final_state)

        return {
            "success": True,
            "session_id": session_id,
            "response": latest_response,
            "current_phase": final_state.get("current_phase"),
            "workflow_complete": final_state.get("workflow_complete", False),
        }

    except Exception as e:
        logger.error(f"Chat error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/chat/stream", summary="Stream chat response")
async def chat_stream(request: ChatRequest):
    """
    Streaming chat endpoint.
    Yields Server-Sent Events (SSE) as each agent node completes.
    Useful for showing real-time progress in the frontend.
    """
    session_id = str(request.session_id)

    session = await db_service.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")

    # Save user message before streaming
    await db_service.save_message(
        session_id=session_id,
        role="user",
        content=request.message,
        phase=session.get("current_phase"),
    )

    existing_state = session.get("metadata", {}).get("graph_state")

    async def event_generator():
        """Generate SSE events as each agent node completes."""
        final_state = None

        try:
            async for update in run_graph_stream(
                session_id=session_id,
                user_input=request.message,
                existing_state=existing_state,
            ):
                node_name = update["node"]
                partial_state = update["state"]
                final_state = partial_state

                # Extract the latest message from this node
                messages = partial_state.get("messages", [])
                latest = messages[-1]["content"] if messages else ""

                event_data = {
                    "node": node_name,
                    "phase": partial_state.get("current_phase"),
                    "content": latest,
                    "workflow_complete": partial_state.get("workflow_complete", False),
                }

                yield f"data: {json.dumps(event_data)}\n\n"

            # Final "done" event
            yield f"data: {json.dumps({'node': 'done', 'phase': 'complete'})}\n\n"

            # Persist final state
            if final_state:
                await _persist_state_updates(session_id, final_state)

        except Exception as e:
            logger.error(f"Streaming error: {e}")
            yield f"data: {json.dumps({'node': 'error', 'content': str(e)})}\n\n"

    return StreamingResponse(
        event_generator(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",
        },
    )


# ------------------------------------------------------------------
# HELPERS
# ------------------------------------------------------------------

async def _persist_state_updates(session_id: str, state: dict):
    """
    Persist relevant state updates to Supabase after graph execution.
    Saves the tech spec, docs, scaffolds, and updates the session.
    """
    try:
        # Update session phase
        current_phase = state.get("current_phase")
        if current_phase:
            # Convert Phase enum to string value
            phase_value = current_phase.value if hasattr(current_phase, 'value') else str(current_phase)
            await db_service.update_session_phase(session_id, phase_value)

        # Save assistant messages
        for msg in state.get("messages", []):
            if msg.get("role") == "assistant":
                await db_service.save_message(
                    session_id=session_id,
                    role="assistant",
                    content=msg["content"],
                    phase=current_phase,
                )

        # Save technical spec (if Planner just finished)
        if state.get("requirements") and state.get("tech_stack"):
            await db_service.save_technical_spec(
                session_id=session_id,
                requirements=state.get("requirements", ""),
                architecture=state.get("architecture", ""),
                tech_stack=state.get("tech_stack", {}),
            )

        # Save documentation links (if Librarian just finished)
        if state.get("documentation_links"):
            await db_service.save_documentation_links(
                session_id=session_id,
                links=state["documentation_links"],
            )

        # Save code scaffolds (if Mentor just finished)
        if state.get("code_scaffolds"):
            await db_service.save_code_scaffolds(
                session_id=session_id,
                scaffolds=state["code_scaffolds"],
            )

        # Store serializable graph state in session metadata for next turn
        serializable_state = {
            "current_phase": state.get("current_phase").value if hasattr(state.get("current_phase"), 'value') else str(state.get("current_phase", "planner")),
            "requirements": state.get("requirements"),
            "architecture": state.get("architecture"),
            "tech_stack": state.get("tech_stack", {}),
            "identified_technologies": state.get("identified_technologies", []),
            "implementation_hints": state.get("implementation_hints", []),
            "iteration_count": state.get("iteration_count", 0),
            "workflow_complete": state.get("workflow_complete", False),
        }
        await db_service.update_session_metadata(
            session_id,
            {"graph_state": serializable_state}
        )

    except Exception as e:
        logger.error(f"State persistence error: {e}")
        # Don't raise â€” persistence failure shouldn't break the response